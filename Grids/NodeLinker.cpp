#include "CKAll.h"
#include "PFUtils.h"
#include "NodeLinker.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// IndoorLink
/////////////////////////////////////////////////////////////////////////////////////////////////////////
IndoorLink::IndoorLink() {}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// IndoorLink
/////////////////////////////////////////////////////////////////////////////////////////////////////////
IndoorLink::~IndoorLink()
{
    m_ListSameGrid.Clear();
    m_ListSameGridCoast.Clear();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// NodeLinker
/////////////////////////////////////////////////////////////////////////////////////////////////////////
NodeLinker::NodeLinker(int maxParallelContext, int numLayer)
    : m_Pos(0),
      m_TypeCase(tc_door),
      m_Occupy(FALSE)
{
    int i;
    m_NumParallelContext = maxParallelContext;
    m_ArrayContextInfo.Resize(maxParallelContext);
    m_DynNodeLinker.Resize(maxParallelContext);
    m_DynNodeLinkerCoast.Resize(maxParallelContext);

    for (i = 0; i < maxParallelContext; i++)
    {
        m_ArrayContextInfo[i] = new LinkerContext();
        m_DynNodeLinker[i] = 0;
    }

    m_NumLayer = numLayer;
    if (numLayer > 0)
        m_ArrayIndoor = new IndoorLink[numLayer];
    else
        m_ArrayIndoor = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ~NodeLinker
/////////////////////////////////////////////////////////////////////////////////////////////////////////
NodeLinker::~NodeLinker()
{
    if (m_Pos)
        delete m_Pos;
    for (int i = 0; i < m_ArrayContextInfo.Size(); i++)
        delete m_ArrayContextInfo[i];
    if (m_ArrayIndoor)
        delete[] m_ArrayIndoor;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ClearConnected
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void NodeLinker::ClearConnected()
{
    m_ListConnected.Clear();
    for (int i = 0; i < m_NumLayer; i++)
    {
        m_ArrayIndoor[i].m_ListSameGrid.Clear();
        m_ArrayIndoor[i].m_ListSameGridCoast.Clear();
        m_ArrayIndoor[i].m_ListSameGridLayerCoast.Clear();
        m_ArrayIndoor[i].m_ListSameGridMaxLayerCoast.Clear();
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ClearDynConnected
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void NodeLinker::ClearDynConnected()
{
    for (int i = 0; i < m_NumParallelContext; i++)
        m_DynNodeLinker[i] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// SetPos
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void NodeLinker::SetPos(VxVector &pos)
{
    m_Pos = new VxVector(pos);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// SetPos
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void NodeLinker::ResizeParallelContext(int numberContext)
{
    int oldNumberContext = m_ArrayContextInfo.Size();

    m_ArrayContextInfo.Resize(numberContext);
    m_DynNodeLinker.Resize(numberContext);
    m_DynNodeLinkerCoast.Resize(numberContext);
    if (numberContext > oldNumberContext)
        for (int i = oldNumberContext; i < numberContext; i++)
        {
            m_ArrayContextInfo[i] = new LinkerContext();
            m_DynNodeLinker[i] = 0;
        }
}

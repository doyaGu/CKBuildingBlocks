#include "CKAll.h"
#include "Path.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// SubPath
/////////////////////////////////////////////////////////////////////////////////////////////////////////
SubPath::SubPath(CKGrid *grid, float coast)
    : m_Coast(0),
      m_Inversed(FALSE)
{
    m_Grid = grid;
    m_Coast = coast;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ~SubPath
/////////////////////////////////////////////////////////////////////////////////////////////////////////
SubPath::~SubPath()
{
    m_ArrayCase.Clear();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// SetTypeCase
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void SubPath::SetLinker(NodeLinker *linkerStart, NodeLinker *linkerEnd)
{
    m_LinkerStart = linkerStart;
    m_LinkerEnd = linkerEnd;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// PushBack
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void SubPath::PushBack(int caze)
{
    m_ArrayCase.PushBack(caze);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// PushFront
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void SubPath::PushFront(int caze)
{
    m_ArrayCase.PushFront(caze);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// NbCase
/////////////////////////////////////////////////////////////////////////////////////////////////////////
int SubPath::NbCase() const
{
    return m_ArrayCase.Size();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetCase
/////////////////////////////////////////////////////////////////////////////////////////////////////////
int SubPath::GetCase(int index) const
{
    if (m_Inversed)
        return m_ArrayCase[m_ArrayCase.Size() - 1 - index];
    return m_ArrayCase[index];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetArrayCase
/////////////////////////////////////////////////////////////////////////////////////////////////////////
XArray<int> *SubPath::GetArrayCase()
{
    return &m_ArrayCase;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inverse
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void SubPath::Inverse()
{
    m_Inversed = !m_Inversed;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Path
/////////////////////////////////////////////////////////////////////////////////////////////////////////
Path::Path() : m_Coast(0),
               m_Inversed(FALSE)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// ~Path
/////////////////////////////////////////////////////////////////////////////////////////////////////////
Path::~Path()
{
    int size = m_ArraySubPath.Size();
    for (int i = 0; i < size; ++i)
        delete m_ArraySubPath[i];
    m_ArraySubPath.Clear();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Clear
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::Clear()
{
    int size = m_ArraySubPath.Size();
    for (int i = 0; i < size; ++i)
        delete m_ArraySubPath[i];
    m_ArraySubPath.Clear();
    m_Inversed = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// AddSubPathFront
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::AddSubPathFront(SubPath *subPath)
{
    m_Coast += subPath->m_Coast + 1;
    m_ArraySubPath.PushFront(subPath);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// AddSubPathBack
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::AddSubPathBack(SubPath *subPath)
{
    m_Coast += subPath->m_Coast + 1;
    m_ArraySubPath.PushBack(subPath);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// NbSubPath
/////////////////////////////////////////////////////////////////////////////////////////////////////////
int Path::NbSubPath() const
{
    return m_ArraySubPath.Size();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetSubPath
/////////////////////////////////////////////////////////////////////////////////////////////////////////
SubPath *Path::GetSubPath(int index)
{
    if (m_Inversed)
        return m_ArraySubPath[m_ArraySubPath.Size() - 1 - index];
    return m_ArraySubPath[index];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetSubPath
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::CopyAndErase(Path &path)
{
    int size = path.NbSubPath();
    for (int i = 0; i < size; ++i)
        AddSubPathBack(path.GetSubPath(i));
    m_ObstacleLayer = path.m_ObstacleLayer;
    m_ObstacleThreshold = path.m_ObstacleThreshold;
    m_LastPoint = path.m_LastPoint;
    m_LinkerObs = path.m_LinkerObs;
    path.m_ArraySubPath.Clear();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inverse
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::Inverse()
{
    m_Inversed = !m_Inversed;
    int size = m_ArraySubPath.Size();
    for (int i = 0; i < size; ++i)
        m_ArraySubPath[i]->Inverse();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// CalculCoast
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void Path::CalculCoast()
{
}